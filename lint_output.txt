Running linters...
/Users/boyd/go/bin/golangci-lint run --config .golangci.yml
cmd/qualhook/format.go:1: 1-77 lines are duplicate of `cmd/qualhook/lint.go:1-88` (dupl)
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/qualhook/qualhook/internal/config"
)

// formatCmd represents the format command
var formatCmd = &cobra.Command{
	Use:   "format [files...]",
	Short: "Run the configured formatting command",
	Long: `Run the configured formatting command for the current project.

This command executes the formatting tool configured in .qualhook.json
and filters its output to provide only relevant error information.

The format command will:
  • Execute your project's formatter (prettier, gofmt, rustfmt, etc.)
  • Filter output to show only actual formatting issues
  • Return appropriate exit codes for Claude Code integration
  • Support monorepo configurations with path-specific formatters

Exit codes:
  0 - No formatting issues found
  1 - Configuration or execution error
  2 - Formatting issues detected (for Claude Code integration)`,
	Example: `  # Format all files in the current project
  qualhook format

  # Format specific files
  qualhook format src/main.js src/utils.js

  # Format with custom config
  qualhook --config ./frontend/.qualhook.json format

  # Format in a monorepo (auto-detects based on current directory)
  cd frontend && qualhook format

  # Common formatters configured:
  # JavaScript/TypeScript: prettier --write
  # Go: gofmt -w
  # Rust: cargo fmt
  # Python: black`,
	RunE: runFormatCommand,
}

func init() {
	rootCmd.AddCommand(formatCmd)
}

func runFormatCommand(cmd *cobra.Command, args []string) error {
	// Load configuration
	loader := config.NewLoader()
	if configPath != "" {
		cfg, err := loader.LoadFromPath(configPath)
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}
		return executeCommand(cfg, "format", args)
	}

	// Load configuration based on current directory
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	cfg, err := loader.LoadForMonorepo(cwd)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	return executeCommand(cfg, "format", args)
}
cmd/qualhook/lint.go:1: 1-88 lines are duplicate of `cmd/qualhook/test.go:1-92` (dupl)
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/qualhook/qualhook/internal/config"
)

// lintCmd represents the lint command
var lintCmd = &cobra.Command{
	Use:   "lint [files...]",
	Short: "Run the configured linting command",
	Long: `Run the configured linting command for the current project.

This command executes the linting tool configured in .qualhook.json
and filters its output to provide only relevant error information.

The lint command will:
  • Execute your project's linter (ESLint, golangci-lint, clippy, etc.)
  • Filter verbose output to show only actual errors and warnings
  • Group errors by file for better readability
  • Provide actionable error messages for the LLM

FILTERING BEHAVIOR:
  Qualhook intelligently filters linter output to:
  • Include error locations (file:line:column)
  • Show error messages and rule names
  • Remove redundant information
  • Limit output size for LLM consumption

Exit codes:
  0 - No linting issues found
  1 - Configuration or execution error
  2 - Linting issues detected (for Claude Code integration)`,
	Example: `  # Lint all files in the current project
  qualhook lint

  # Lint specific files
  qualhook lint src/app.js src/components/

  # Lint with specific severity (if supported by linter)
  qualhook lint --error-only

  # Lint in debug mode to see full output
  qualhook --debug lint

  # Common linters configured:
  # JavaScript/TypeScript: eslint
  # Go: golangci-lint run
  # Rust: cargo clippy
  # Python: pylint, flake8, ruff

  # Example filtered output:
  # src/main.js:10:5: error: 'unused' is defined but never used [no-unused-vars]
  # src/utils.js:25:1: warning: Missing semicolon [semi]`,
	RunE: runLintCommand,
}

func init() {
	rootCmd.AddCommand(lintCmd)
}

func runLintCommand(cmd *cobra.Command, args []string) error {
	// Load configuration
	loader := config.NewLoader()
	if configPath != "" {
		cfg, err := loader.LoadFromPath(configPath)
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}
		return executeCommand(cfg, "lint", args)
	}

	// Load configuration based on current directory
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	cfg, err := loader.LoadForMonorepo(cwd)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	return executeCommand(cfg, "lint", args)
}
cmd/qualhook/test.go:1: 1-92 lines are duplicate of `cmd/qualhook/typecheck.go:1-85` (dupl)
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/qualhook/qualhook/internal/config"
)

// testCmd represents the test command
var testCmd = &cobra.Command{
	Use:   "test [test-files-or-patterns...]",
	Short: "Run the configured test command",
	Long: `Run the configured test command for the current project.

This command executes the test tool configured in .qualhook.json
and filters its output to provide only relevant error information.

The test command will:
  • Execute your project's test runner (jest, go test, cargo test, pytest, etc.)
  • Filter test output to show only failures and errors
  • Provide clear failure messages with file locations
  • Include relevant stack traces without noise

TEST OUTPUT FILTERING:
  Qualhook intelligently processes test output to:
  • Show failed test names and assertions
  • Include error messages and diffs
  • Display file locations for quick navigation
  • Remove verbose setup/teardown logs

Exit codes:
  0 - All tests passed
  1 - Configuration or execution error
  2 - Test failures detected (for Claude Code integration)`,
	Example: `  # Run all tests
  qualhook test

  # Run specific test files
  qualhook test src/__tests__/api.test.js

  # Run tests matching a pattern
  qualhook test "**/user*.test.js"

  # Run tests in watch mode (if supported)
  qualhook test --watch

  # Common test runners configured:
  # JavaScript/TypeScript: jest, vitest, mocha
  # Go: go test ./...
  # Rust: cargo test
  # Python: pytest, unittest

  # Example filtered output:
  # FAIL src/utils.test.js
  #   calculateTotal
  #     ✕ should return sum of items (5ms)
  #       Expected: 150
  #       Received: 140
  #       at src/utils.test.js:15:23`,
	RunE: runTestCommand,
}

func init() {
	rootCmd.AddCommand(testCmd)
}

func runTestCommand(cmd *cobra.Command, args []string) error {
	// Load configuration
	loader := config.NewLoader()
	if configPath != "" {
		cfg, err := loader.LoadFromPath(configPath)
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}
		return executeCommand(cfg, "test", args)
	}

	// Load configuration based on current directory
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	cfg, err := loader.LoadForMonorepo(cwd)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	return executeCommand(cfg, "test", args)
}
cmd/qualhook/typecheck.go:1: 1-85 lines are duplicate of `cmd/qualhook/format.go:1-77` (dupl)
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/qualhook/qualhook/internal/config"
)

// typecheckCmd represents the typecheck command
var typecheckCmd = &cobra.Command{
	Use:   "typecheck [files...]",
	Short: "Run the configured type checking command",
	Long: `Run the configured type checking command for the current project.

This command executes the type checking tool configured in .qualhook.json
and filters its output to provide only relevant error information.

The typecheck command will:
  • Execute your project's type checker (tsc, mypy, flow, etc.)
  • Filter complex type error messages to their essence
  • Highlight the specific type mismatches
  • Provide clear error locations and suggestions

TYPE CHECKING TOOLS:
  Qualhook supports various type checkers:
  • TypeScript: tsc --noEmit
  • Python: mypy, pyright
  • Flow: flow check
  • Go: Built into go build/test

Exit codes:
  0 - No type errors found
  1 - Configuration or execution error
  2 - Type errors detected (for Claude Code integration)`,
	Example: `  # Type check entire project
  qualhook typecheck

  # Type check specific files
  qualhook typecheck src/models.ts src/api.ts

  # Type check with strict mode (if configured)
  qualhook typecheck --strict

  # Common type checkers configured:
  # TypeScript: tsc --noEmit
  # Python: mypy --show-error-codes
  # Flow: flow check
  # Haskell: ghc -fno-code

  # Example filtered output:
  # src/api.ts:45:12: error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'
  # src/models.py:23: error: Incompatible return value type (got "str", expected "int")`,
	RunE: runTypecheckCommand,
}

func init() {
	rootCmd.AddCommand(typecheckCmd)
}

func runTypecheckCommand(cmd *cobra.Command, args []string) error {
	// Load configuration
	loader := config.NewLoader()
	if configPath != "" {
		cfg, err := loader.LoadFromPath(configPath)
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}
		return executeCommand(cfg, "typecheck", args)
	}

	// Load configuration based on current directory
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	cfg, err := loader.LoadForMonorepo(cwd)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	return executeCommand(cfg, "typecheck", args)
}
cmd/qualhook/completion.go:62:4: Error return value of `(*github.com/spf13/cobra.Command).GenBashCompletion` is not checked (errcheck)
			_ = cmd.Root().GenBashCompletion(os.Stdout)
			^
cmd/qualhook/completion.go:64:4: Error return value of `(*github.com/spf13/cobra.Command).GenZshCompletion` is not checked (errcheck)
			_ = cmd.Root().GenZshCompletion(os.Stdout)
			^
cmd/qualhook/completion.go:66:4: Error return value of `(*github.com/spf13/cobra.Command).GenFishCompletion` is not checked (errcheck)
			_ = cmd.Root().GenFishCompletion(os.Stdout, true)
			^
cmd/qualhook/completion.go:68:4: Error return value of `(*github.com/spf13/cobra.Command).GenPowerShellCompletion` is not checked (errcheck)
			_ = cmd.Root().GenPowerShellCompletion(os.Stdout)
			^
cmd/qualhook/execute.go:236:6: Error return value of `fmt.Fprintln` is not checked (errcheck)
		_, _ = fmt.Fprintln(os.Stdout, report.Stdout)
		   ^
cmd/qualhook/template.go:99:2: Error return value of `exportCmd.MarkFlagRequired` is not checked (errcheck)
	_ = exportCmd.MarkFlagRequired("name")
	^
cmd/qualhook/template.go:252:5: Error return value of `fmt.Fprintln` is not checked (errcheck)
	_, _ = fmt.Fprintln(w, "NAME\tDESCRIPTION\tCREATED")
	   ^
cmd/qualhook/template.go:253:5: Error return value of `fmt.Fprintln` is not checked (errcheck)
	_, _ = fmt.Fprintln(w, "----\t-----------\t-------")
	   ^
cmd/qualhook/template.go:272:6: Error return value of `fmt.Fprintf` is not checked (errcheck)
		_, _ = fmt.Fprintf(w, "%s\t%s\t%s\n", tmpl.Name, desc, created)
		   ^
cmd/qualhook/template.go:275:2: Error return value of `w.Flush` is not checked (errcheck)
	_ = w.Flush()
	^
internal/config/loader.go:127:17: Error return value of `file.Close` is not checked (errcheck)
	defer func() { _ = file.Close() }()
	               ^
internal/config/loader.go:259:17: Error return value of `file.Close` is not checked (errcheck)
	defer func() { _ = file.Close() }()
	               ^
internal/debug/logger.go:56:5: Error return value of `fmt.Fprint` is not checked (errcheck)
	_, _ = fmt.Fprint(globalLogger.writer, prefix+message)
	   ^
internal/executor/command.go:134:3: Error return value is not checked (errcheck)
		_ = HandleTimeoutCleanup(cmd)
		^
internal/executor/command.go:244:3: Error return value is not checked (errcheck)
		_ = HandleTimeoutCleanup(cmd)
		^
internal/executor/errors.go:174:5: Error return value of `cmd.Process.Wait` is not checked (errcheck)
	_, _ = cmd.Process.Wait()
	   ^
internal/executor/test_helpers.go:73:3: Error return value is not checked (errcheck)
		_ = HandleTimeoutCleanup(cmd)
		^
internal/executor/test_helpers.go:143:3: Error return value is not checked (errcheck)
		_ = HandleTimeoutCleanup(cmd)
		^
internal/filter/optimizations.go:218:9: Error return value is not checked (errcheck)
	return bm.bufferPool.Get().([]byte)
	       ^
internal/filter/output.go:168:3: Error return value of `bufWriter.Flush` is not checked (errcheck)
		_ = bufWriter.Flush()
		^
internal/filter/output.go:194:8: Error return value of `fmt.Fprintln` is not checked (errcheck)
				_, _ = fmt.Fprintln(bufWriter, contextLine)
				   ^
internal/filter/output.go:196:4: Error return value of `bufWriter.Flush` is not checked (errcheck)
			_ = bufWriter.Flush()
			^
internal/filter/output.go:395:9: Error return value is not checked (errcheck)
	cache, _ := NewPatternCache()
	       ^
internal/filter/patterns.go:138:10: Error return value is not checked (errcheck)
		cache, _ = NewPatternCache()
		       ^
internal/filter/patterns.go:303:10: Error return value is not checked (errcheck)
		cache, _ = NewPatternCache()
		       ^
internal/security/validator.go:330:12: Error return value of `regexp.MatchString` is not checked (errcheck)
		matched, _ := regexp.MatchString(vp.pattern, pattern)
		         ^
internal/config/defaults_test.go:335:17: string `modified` has 3 occurrences, make it a constant (goconst)
	cfg1.Version = "modified"
	               ^
internal/config/validator.go:259:21: string `windows` has 3 occurrences, make it a constant (goconst)
	if runtime.GOOS != "windows" && len(pattern) >= 3 && 
	                   ^
internal/executor/parallel_test.go:58:22: string `windows` has 22 occurrences, make it a constant (goconst)
		if runtime.GOOS == "windows" {
		                   ^
internal/executor/parallel_test.go:62:10: string `echo` has 7 occurrences, make it a constant (goconst)
			cmd = "echo"
			      ^
internal/executor/parallel_test.go:131:10: string `cmd` has 17 occurrences, make it a constant (goconst)
			cmd = "cmd"
			      ^
pkg/config/config_test.go:710:30: string `modified` has 4 occurrences, make it a constant (goconst)
	clone.Patterns[0].Pattern = "modified"
	                            ^
internal/config/validator.go:347:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if strings.Contains(errStr, "npm") {
		^
internal/executor/errors.go:142:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if strings.Contains(errStr, "permission denied") {
	^
internal/executor/parallel.go:225:4: ifElseChain: rewrite if-else to switch statement (gocritic)
			if result.TimedOut {
			^
internal/watcher/mapper_test.go:301:4: ifElseChain: rewrite if-else to switch statement (gocritic)
			if spec1 > spec2 {
			^
cmd/qualhook/execute.go:23:1: cyclomatic complexity 26 of func `executeCommand` is high (> 15) (gocyclo)
func executeCommand(cfg *config.Config, commandName string, extraArgs []string) error {
^
internal/config/validator.go:70:1: cyclomatic complexity 16 of func `(*Validator).validateCommand` is high (> 15) (gocyclo)
func (v *Validator) validateCommand(name string, cmd *config.CommandConfig) error {
^
internal/executor/errors.go:98:1: cyclomatic complexity 16 of func `ClassifyError` is high (> 15) (gocyclo)
func ClassifyError(err error, command string, args []string) *ExecError {
^
internal/executor/file_aware.go:58:1: cyclomatic complexity 21 of func `(*FileAwareExecutor).ExecuteForEditedFiles` is high (> 15) (gocyclo)
func (e *FileAwareExecutor) ExecuteForEditedFiles(hookInput *hook.HookInput, commandName string, extraArgs []string) ([]ComponentExecResult, error) {
^
internal/security/validator.go:83:1: cyclomatic complexity 21 of func `(*SecurityValidator).ValidatePath` is high (> 15) (gocyclo)
func (v *SecurityValidator) ValidatePath(path string) error {
^
internal/security/validator.go:254:1: cyclomatic complexity 19 of func `(*SecurityValidator).checkDangerousCommands` is high (> 15) (gocyclo)
func (v *SecurityValidator) checkDangerousCommands(command string, args []string) error {
^
internal/wizard/config.go:37:1: cyclomatic complexity 33 of func `(*ConfigWizard).Run` is high (> 15) (gocyclo)
func (w *ConfigWizard) Run(outputPath string, force bool) error {
^
internal/wizard/config.go:233:1: cyclomatic complexity 19 of func `(*ConfigWizard).createManualConfiguration` is high (> 15) (gocyclo)
func (w *ConfigWizard) createManualConfiguration() (*pkgconfig.Config, error) {
^
cmd/qualhook/commands_test.go:121:5: SA5011(related information): this check suggests that the pointer can be nil (staticcheck)
	if validateFlag == nil {
	   ^
cmd/qualhook/commands_test.go:124:18: SA5011: possible nil pointer dereference (staticcheck)
	if validateFlag.DefValue != "false" {
	                ^
cmd/qualhook/completion.go:58:25: SA1019: cobra.ExactValidArgs is deprecated: use MatchAll(ExactArgs(n), OnlyValidArgs) instead (staticcheck)
	Args:                  cobra.ExactValidArgs(1),
	                       ^
internal/config/loader.go:169:2: SA9003: empty branch (staticcheck)
	if pathConfig.Extends != "" && pathConfig.Extends != "." {
	^
internal/filter/optimizations.go:224:20: SA6002: argument should be pointer-like to avoid allocations (staticcheck)
	bm.bufferPool.Put(buf)
	                  ^
internal/filter/optimizations_bench_test.go:185:17: SA4010: this result of append is never used, except maybe in other appends (staticcheck)
						matches = append(matches, lineNum)
						          ^
54 issues:
* dupl: 4
* errcheck: 26
* goconst: 6
* gocritic: 4
* gocyclo: 8
* staticcheck: 6
make: *** [lint] Error 1
